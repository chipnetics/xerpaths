link ximage
link fullimag
link strings
link tuple

record r_relation(rel_type,start_id,end_id)
record r_task(task_id,task_code,task_name,
                base_start,base_finish,base_duration,
                target_start,target_finish,
                actual_start,actual_finish,
                early_start,early_finish,
                late_start,late_finish,
                is_completed,actual_duration,
                opti_duration,target_duration,pess_duration,
                pert_mean,prior_alpha,prior_beta,
                evidence,pace)


# Record for import of ranging template fields (only what's neccessary)
record r_ranging_template(task_code,category,opti_decimal,pess_decimal)

global g_arr_relations,g_tbl_tasks_code,g_tbl_tasks_id,g_tbl_ranging_template


# procedure to load the ranging template
procedure import_ranging_template(ranging_filename)
    local ranging_file := open(ranging_filename,"r") | stop("Cannot open ranging file.")
    every put(ranging_data := [],!ranging_file)
    pop(ranging_data)  # Pop off the header.
    g_tbl_ranging_template := table()
    every ranging_line := !ranging_data do {
        fields := fieldlist(ranging_line,"\t")
        insert(g_tbl_ranging_template,fields[1],r_ranging_template(fields[1],fields[3],fields[4],fields[5]))
    }
end

# procedure to update the target duration in the structures with the original baseline duration
# hopefully for better accuracy.
procedure update_curr_structures(xer_filename)

    local xer_file := open(xer_filename,"r") | stop("Cannot open XER file to set as baseline.")
    every put(xer_data := [],!xer_file)

    index := 1
    every xer_line := !xer_data do {
        
        if xer_line == "%T\tTASK" then {
            #write(i," ",xer_line)
            every i:=index+2 to *xer_data do {
                if find("%T",xer_data[i])==1 then break
                fields := fieldlist(xer_data[i],"\t")
                #write(i," ",xer_data[i])
                # If the task_name exists in the table then populate baseline start/finish/duration members in record.
                #xxx
                if \g_tbl_tasks_code[fields[15]] then{
                    #write("found",fields[15])
                    g_tbl_tasks_code[fields[15]].base_start := fields[38]
                    g_tbl_tasks_code[fields[15]].base_finish := fields[39]
                    g_tbl_tasks_code[fields[15]].base_duration := days_diff(replace(fields[38],"-","/"),replace(fields[39],"-","/"))
                }       
            }
        }   
        index +:= 1
    }

end

procedure load_structures(xer_filename)
    local xer_file := open(xer_filename,"r") | stop("Cannot open XER file.")
    every put(xer_data := [],!xer_file)

    g_arr_relations:= []
    g_tbl_tasks_code:= table()
    g_tbl_tasks_id:= table()
    
    index := 1
    every xer_line := !xer_data do {
        if xer_line == "%T\tTASKPRED" then {
            every i:=index+2 to *xer_data do {
                if find("%T",xer_data[i])==1 then break
                fields := fieldlist(xer_data[i],"\t")
                put(g_arr_relations,r_relation(fields[7],fields[4],fields[3]))
            }
        }
        else if xer_line == "%T\tTASK" then {
            every i:=index+2 to *xer_data do {
                if find("%T",xer_data[i])==1 then break
                fields := fieldlist(xer_data[i],"\t")
                
                # Check if 100% complete, if so use actual dates o.w. use target dates.
                if fields[6]==100 then iscmpl:="Y" & act_duration:=days_diff(replace(fields[29],"-","/"),replace(fields[30],"-","/"))  else iscmpl:="" & act_duration:=""
                
                target_duration := days_diff(replace(fields[38],"-","/"),replace(fields[39],"-","/")) # target duration -> likely duration.
                
                opti := target_duration*?[0.6,0.65,0.7,0.75,0.8,0.85,0.90]
                pess := target_duration*?[1.1,1.15,1.2,1.25,1.3,1.35,1.4]

                if fields[6]==100 & (pess-opti)>0.001 & *act_duration>0 then evidence:=(act_duration-opti)/(pess-opti) & pace:=5 else evidence:="" & pace:=""
                
                # Put the struct into the table, with task_name as key.
                insert(g_tbl_tasks_code,fields[15],r_task(fields[2],fields[15],fields[16],
                        "","","",  # Baseline start/finish/duration blank on initial load, unless user selects a baseline file.
                        fields[38],fields[39],
                        fields[29],fields[30],
                        fields[34],fields[35],
                        fields[31],fields[32],
                        iscmpl,act_duration,
                        opti,target_duration,pess,
                        beta_mean(opti,target_duration,pess),prior_alpha(opti,target_duration,pess),prior_beta(opti,target_duration,pess),
                        evidence,pace))
                insert(g_tbl_tasks_id,fields[2],fields[15])
             }
        }
        index +:= 1
    }
end

procedure print_tasks(taskid_list)
    every task := !taskid_list do write("\t",g_tbl_tasks_code[g_tbl_tasks_id[task]].task_id,"\t",g_tbl_tasks_code[g_tbl_tasks_id[task]].task_code,"\t",g_tbl_tasks_code[g_tbl_tasks_id[task]].task_name)
end

# Generates complete paths starting from 'from'
procedure gen_path(from)
    static generated := []
    every dest:=destination(from) do {
        if *generated = 0 then put(generated,from)  # Start of new generated path.
        put(generated,dest)
        gen_path(dest)
        suspend generated
        generated := []
     }
end

# Generates possible destinations from 'from'
procedure destination(from)
    repeat {
        every i:=1 to *g_arr_relations do {
            if g_arr_relations[i].start_id == from then {
                suspend g_arr_relations[i].end_id
            }
        }
        fail
    }
end

procedure beta_mean(opti,likely,pess)
    return ((pess+4*likely+opti)/6.0)
end

procedure prior_alpha(opti,likely,pess)
    if opti == pess | (pess-likely)-(likely-opti) < 0.001  then return 3
    else return (((pess+4*likely+opti)/6.0)-opti)*(2*likely-opti-pess)/((likely-((pess+4*likely+opti)/6.0))*(pess-opti))|3
end

procedure prior_beta(opti,likely,pess)
    if opti == pess | (pess-likely)-(likely-opti) < 0.001  then return 3
    else return ((((pess+4*likely+opti)/6.0)-opti)*(2*likely-opti-pess)/((likely-((pess+4*likely+opti)/6.0))*(pess-opti))*(pess-((pess+4*likely+opti)/6.0)))/(((pess+4*likely+opti)/6.0)-opti)
end

procedure post_alpha(opti,actual,pess,pace)
    return prior_alpha(opti,likely,pess) + ((actual-opti)/(pess-opti))*pace
end

procedure post_beta(opti,actual,pess,pace)
    return prior_beta(opti,likely,pess) + pace - ((actual-opti)/(pess-opti))*pace
end

procedure gamma(z)	# Stirling's approximation
    return (2*&pi/z)^0.5 * (z/&e)^z
end

procedure beta(a,b)
    return (gamma(a)*gamma(b))/gamma(a+b)
end

class beta4()

    local alpha
    local beta
    local a
    local b

    method pdf(y)
        return (1/(b-a))*((((y-a)/(b-a))^(alpha-1)*(1-((y-a)/(b-a))^(beta-1)))/beta(alpha,beta))
    end

end

